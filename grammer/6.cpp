/*2022年10月22日22:38:09
引用变量和引用传递*/
#include <iostream>

using namespace std;

//这里是基本类型的引用
double sum(const double &ra,const double &rb);
int abs(int &x);
void swap(const double &ra,const double &rb);
//这里是数组的引用（灰常重要）
//首先要分清楚引用的数组和数组的引用：见main函数
void sumarray(int (&a)[10]);//首先这是数组的引用
//其次，但是不能直接声明数组的引用：int (&a)[],因为引用类型也是一个变量，你要构建一个数组的引用，不给数据大小是不行的
//但是这就产生了一个问题，这个函数现在变的只能处理大小为20的数组了
//如何进行动态传递呢？，这就要运用到模板的特性了
//编译器编译期间会自动推断出类型的大小，由于我们传递的是大小已知的数组，那么函数是可以推断出该长度的可以达到动态获取数组的大小
template<int N>
void sumarr(int (&a)[N]);

//这里是结构的引用
//就和普通的基本类型一样

int main (void)
{
    int rats;
    int &rodents=rats;//实际上等价于下面语句
    int *const pr=&rats;
    //其中&不是取地址操作符，而是类型标识符的一部分
    //在声明引用时必须对它初始化，一旦与某个变量关联起来就会一直效忠于他，即只能赋一次值

    //不要给引用变量二次赋值：
    int a=3;
    int &b=a;
    int c=4;
    b=c;//实际上是把a,b的值改为4，而不是让b成为c的引用变量
    cout<<abs(-3)<<endl;
    cout<<sum(c+4,a+4);//测试临时变量的作用
    //实际上c+4,a+4都不是合法的左值，此时因为sum函数是常值引用，因此创建了一个临时变量，并把它的值初始化为c+4，
    //然后ra成为该临时变量的引用
    //最重要的一点是，为什么c++限定只有在const引用是才会创建临时变量辅助呢
    //关键则在于下面的swap函数
    int x=2,y=3;
    swap(x,y);//按照我们理解，int通过临时变量转换为double，
    //但是被引用的变量是这个临时变量，我们原本的目的是要通过引用传递来交换x，y的值，但是引用临时变量
    //并不能改变x，y，也就是说，这和设计者的理念不符合
    //也就是说触发了临时变量的规则时，实际上只有值被传递过去了
    //因此，在const引用时，因为设计者的目的就是不改变传入进去的值，所以才会触发临时变量的规则，即默认不能改变值
    //否则将会误导开发者


    //这里是数组的引用（灰常重要）
    //首先要分清楚引用的数组和数组的引用
    int &array[];//假设这是在函数中(只有在函数原型中可以这么写)
    //array和优先级高的[]结合，先变成一个数组，再和int &结合，因此本质为一个数组，数组元素为引用类型
    //就类似于int *array[5]是含有五个指针的数组，而int (*array)[5]是一个指向五个int的指针
    //所以这种写法没什么用，因为你必须初始化，但是它又有多个元素，你没法在声明时全部初始化
    int (&array)[];//假设这是在函数中(只有在函数原型中可以这么写)
    //先和&结合，说明它是引用类型，指向一个int类型的数组，这在自己构造的函数中有作用了


    //上述都是左值引用，也就是一个&，但是c++中还存在着右值引用。如下所示：
    int &&a;
}

int abs(const int &x)//int abs(const int &x)
{//引用是原定义的变量的别名，这将会使x成为传入变量的别名，对其中任意一个进行改变，两个都会改变
//按引用传递允许被调用的函数能够访问调用函数（main函数）中的变量
    int y=x>>31;
    return (x^y)-y;
}
//按值传递的函数，可以使用多种类型的实参（只要求出来是符合数据类型的值就行）
//但是引用传递的函数的限制更严格，毕竟如果引用变量是一个变量的别名，则实参则应该是变量，不应是表达式，常值之类的东西
//但也有相关的措施，如果实参和引用参数的数据类型不匹配，c++将生成临时变量，但仅当参数声明为const引用时c++才允许这么做
//首先：创建临时变量发生于以下两种情况下
//1.实参的类型正确，但不是左值（也就是不能被引用）
//左值参数指可以被引用的数据对象，如变量，数组元素，结构成员，引用和被解除引用的指针
//非左值参数包括字面常量和包含多项的表达式
//2.实参的类型不正确但是可以转换为正确的类型，如：char*转string，int转double
//临时变量的作用是：例：
double sum(const double &ra,const double &rb)//仅当参数声明为const引用时c++才允许这么做 
{
    int answer;
    return answer=ra+rb;
}

void swap(const double &ra,const double &rb)
{
    int temp;
    temp=ra;
    ra=rb;//因为这里是const引用，也就是说ra是不可改变的，仅解释原理
    rb=temp;
}