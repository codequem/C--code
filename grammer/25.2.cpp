/*2022年11月19日18:36:27
类的自动转换和强制类型转换*/

//其他类型--------->类类型--------构造函数
//类类型----------->其他类型------转换函数

#include "25.h"
#include <iostream>

using std::cout;
using std::endl;
using std::cin;

int main(void)
{
    stonewt mycat;//创建一个stonewt类对象
    mycat=19.6;//这一步很有意思，实际上只允许相同的类对象之间互相赋值
    //程序将使用构造函数stonewt(double) 来创建一个临时的stonewt对象，并将19.6作为初始化值，随后采用成员赋值的方法
    //将这个临时对象的内容复制到mycat中      //这个过程叫做隐式转换，它是自动进行的，而不需要显式强制转换
    //只有接受一个参数的沟槽函数才能作为转换函数

    //但这种特性不总是好的，如果你要关闭这种自动的隐式转化特性，可以在构造函数前加上关键字explicit
    //即改成：explicit stonewt(double)
    //但仍然允许显式转换，即支持以下语句
    mycat=stonewt(24.4);
    mycat=(stonewt)12.8;//这两条语句是等价于上面那条语句的
    //但区别是，这两条语句可以用于接受多个参数的构造函数，原理就是对象赋值罢了
    
    //即，只接受一个参数的构造函数定义了从参数类型到类类型的转换，如果在声明中使用explicit，则该构造函数只允许显式转换
    //否则它也可以用来进行隐式转换

    //隐式转换的时机：
    //将类对象初始化为参数类型（这里是double）时
    //将参数类型赋给类对象时
    //将参数类型传递给使用类对象的函数时
    //返回值声明为类对象的函数试图返回一个参数类型时
    //在上述任意一种情况下，使用可转换为double类型的内置类型

    //这里详细解释最后一点：
    mycat=stonewt(16);//这是可行的，进行了二步转换，先将16转换为double类型，再隐式转换
    //但必须确保这种操作不存在二义性
    //例如，若存在stonewt(long)这样的构造函数，则上述语句将会报错，因为不知道16是转换为double类型还是long类型

    //上面的所有语句都是将其他类型转化为类类型，那么是否能将类类型转换为其他类型呢？
    //这就是转换函数干的事了：
    //转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们
    int a;
    a=int(mycat);
    //转换函数也存在隐式转换，而且explicit不能用于转换函数（类成员函数），explicit只能用于类构造函数，如果定义了一个转换函数，那么无论是显式的调用它
    //还是隐式时不知情的使用它都是可能的（当二义性存在时不会）


    //最好定义非转换函数替换该转换函数（或者说应该谨慎地使用隐式转换）
    a = mycat.stone_to_int();//即只允许显式使用转换函数
}